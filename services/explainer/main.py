from __future__ import annotations

from datetime import datetime, timezone
from typing import List

from fastapi import Depends, FastAPI
from pydantic import BaseModel, Field

from packages.kernel_common.deps import require_auth
from packages.kernel_common.logging import configure_logging
from packages.llm import generate_explanation_llm

logger = configure_logging("explainer-service")

def generate_explanation(goal: str, solution: dict, forecasts: List[dict], policy: dict | None, diagnostics: dict | None) -> ExplainResponse:
    timestamp = datetime.now(tz=timezone.utc).isoformat()
    kpis = solution.get("kpis", {})
    total_cost = kpis.get("total_holding_cost")

    highlights = [
        f"Objective value: {total_cost}" if total_cost is not None else "Objective value unavailable",
        f"Decisions produced: {len(solution.get('decisions', {}))}",
    ]

    if forecasts:
        highlights.append(f"Forecast inputs: {len(forecasts)} points considered")

    if policy:
        highlights.append(f"Policy verdict: {policy.get('verdict', 'unknown')}")

    if diagnostics:
        suggestions = diagnostics.get("suggestions", [])
        highlights.append(f"Diagnostics suggestions: {len(suggestions)} available")

    what_ifs = [
        "Try reducing demand by 10% to evaluate sensitivity.",
        "Adjust holding costs to explore alternative supplier scenarios.",
    ]

    llm_payload = generate_explanation_llm(goal, solution, highlights, what_ifs)
    if llm_payload:
        return ExplainResponse(
            generated_at=timestamp,
            summary=llm_payload["summary"],
            highlights=llm_payload["highlights"],
            what_ifs=llm_payload["what_ifs"],
        )

    summary = (
        f"The optimiser generated a plan aligned with the goal '{goal}'. "
        "Policy checks authorised execution and diagnostics produced relaxation options. "
        "The current stub emphasises inventory cost minimisation; future versions "
        "will include narrative generated by LLMs."
    )

    return ExplainResponse(
        generated_at=timestamp,
        summary=summary,
        highlights=highlights,
        what_ifs=what_ifs,
    )


app = FastAPI(
    title="Dyocense Explainer Service",
    version="0.6.0",
    description="Phase 3 stub that generates templated explanations for solutions including policy and diagnostics context.",
)


class ExplainRequest(BaseModel):
    goal: str = Field(..., description="Original optimisation goal.")
    solution: dict = Field(..., description="SolutionPack payload returned by optimiser.")
    forecasts: List[dict] = Field(
        default_factory=list,
        description="Optional list of forecast points included in the plan.",
    )
    policy: dict | None = Field(
        default=None,
        description="Policy evaluation payload to reference in the explanation.",
    )
    diagnostics: dict | None = Field(
        default=None,
        description="Diagnostician response with relaxation suggestions.",
    )


class ExplainResponse(BaseModel):
    generated_at: str
    summary: str
    highlights: List[str]
    what_ifs: List[str]


@app.post("/v1/explain", response_model=ExplainResponse)
def explain(body: ExplainRequest, identity: dict = Depends(require_auth)) -> ExplainResponse:
    """
    Produce a templated explanation anchored on the solution objective.
    """
    logger.info(
        "Generating explanation for goal '%s' (tenant=%s)",
        body.goal,
        identity["tenant_id"],
    )
    return generate_explanation(body.goal, body.solution, body.forecasts, body.policy, body.diagnostics)
